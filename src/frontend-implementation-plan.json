{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Sync Swarm Health Dashboard with Backend Agent Registry",
  "requirements": [
    {
      "id": "REQ-96",
      "summary": "Import backend actor and initialize agents state in AgentRegistryTable component",
      "acceptanceCriteria": [
        "Backend actor is destructured from useActor hook at component top",
        "React state agents is declared with type annotation",
        "State is initialized as empty array"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "Import useActor hook from '../hooks/useActor' if not already imported. Add a React state declaration using useState: const [agents, setAgents] = useState<any[]>([]) to store the agent list fetched from the backend. Ensure the backend actor is destructured from useActor at the component top level."
        }
      ]
    },
    {
      "id": "REQ-97",
      "summary": "Fetch agent registry data on component mount using useEffect",
      "acceptanceCriteria": [
        "useEffect has empty dependency array [] to run only on mount",
        "useEffect contains async function that calls backend.get_agent_registry()",
        "Returned agent data is stored in agents state via setAgents",
        "Error handling is included for failed backend calls"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "Implement a useEffect hook with empty dependency array [] that runs on component mount. Inside the effect, create an async function that calls await backend.getAgentRegistry() (note: backend interface uses camelCase getAgentRegistry, not snake_case). Store the returned agent array in the agents state using setAgents. Include try-catch error handling for failed backend calls and log errors appropriately."
        }
      ]
    },
    {
      "id": "REQ-98",
      "summary": "Refactor table rendering to dynamically map over agents state instead of hardcoded HTML",
      "acceptanceCriteria": [
        "Table body uses agents.map() to generate rows",
        "No hardcoded agent names in JSX",
        "Each row displays agent.name field",
        "Rows update automatically when agents state changes"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "Replace any hardcoded table row HTML with dynamic rendering using agents.map((agent) => ...). Each mapped row must display agent.name for the agent name column. Remove all hardcoded agent names from JSX. Ensure each row has a unique key prop using agent.id or agent.name. The table body should automatically re-render when the agents state changes."
        }
      ]
    },
    {
      "id": "REQ-99",
      "summary": "Bind Toggle components to reflect true agent.isEnabled boolean values from backend state",
      "acceptanceCriteria": [
        "Toggle component receives agent.isEnabled as checked or value prop",
        "Toggle visual state matches backend isEnabled value",
        "Green indicator displays when isEnabled is true",
        "Red indicator displays when isEnabled is false"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "Update each Toggle component in the mapped table rows to receive agent.isEnabled as its checked or value prop (note: backend interface uses camelCase isEnabled, not snake_case is_enabled). Ensure the Toggle visual state correctly reflects the backend isEnabled boolean value. Green indicator (#39FF14) should display when isEnabled is true, and red indicator should display when isEnabled is false, maintaining the tactical dark aesthetic."
        }
      ]
    },
    {
      "id": "REQ-100",
      "summary": "Add toggle click handler that calls backend toggleAgentStatus with inverted status",
      "acceptanceCriteria": [
        "Toggle has onChange or onClick handler implemented",
        "Handler calls backend.toggleAgentStatus with correct parameters",
        "First parameter is agent.name from current row",
        "Second parameter is !agent.isEnabled (inverted current state)",
        "Handler is properly async or wrapped in async function"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "Add an onChange or onClick event handler to each Toggle component in the mapped rows. The handler must call await backend.toggleAgentStatus(agent.name, !agent.isEnabled) (note: backend interface uses camelCase toggleAgentStatus and isEnabled, not snake_case). The first parameter is the agent's name string from the current row, and the second parameter is the inverted enabled status (!agent.isEnabled). Ensure the handler is properly async or wrapped in an async function with error handling."
        }
      ]
    },
    {
      "id": "REQ-101",
      "summary": "Refresh agent data immediately after toggle status change to update UI in real-time",
      "acceptanceCriteria": [
        "After toggleAgentStatus completes, getAgentRegistry is called",
        "Fresh agent data is stored in agents state via setAgents",
        "UI updates reflect the new backend state immediately",
        "Toggle indicators update to show new enabled/disabled status without page refresh"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AgentRegistryTable.tsx",
          "operation": "modify",
          "description": "After the await backend.toggleAgentStatus() call resolves successfully in the toggle handler, immediately call await backend.getAgentRegistry() again to fetch the updated agent data from the backend. Store the fresh agent array in the agents state using setAgents() to update the UI in real-time. This ensures toggle indicators update to show the new enabled/disabled status without requiring a page refresh. Include error handling for the refresh call."
        }
      ]
    }
  ]
}