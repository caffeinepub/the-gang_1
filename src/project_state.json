{
  "schemaVersion": "1.0.0",
  "projectStateVersion": 69,
  "summary": "A sovereign, decentralized multi-agent system called 'The Gang' on the Internet Computer, consisting of 8 AI agent canisters plus 1 ingestion canister, all controlled by a single Principal ID with strict sovereignty",
  "architectural_notes": [
    "Multi-canister architecture: 8 AI agents + 1 ingestion canister",
    "All canisters controlled by single Principal ID (Identity #2)",
    "Strict sovereignty: no data leaves chain except through vetKey-gated periscope",
    "The Researcher agent has special vetKey-gated periscope for external data access",
    "The_Orchestrator canister serves as central coordinator with StableBTreeMap for file storage",
    "File chunk size limited to 1.8MB to fit IC message limits",
    "390GB storage cap enforced to stay under IC physical limits",
    "8 external C++ LLM agent canisters (Robby, Skippy, The_Architect, Deep_Thought, GLaDOS, VINCENT, Janet, The_Librarian) deployed separately",
    "Inter-canister communication via ask_agent(Text)->async Text interface",
    "HTTP polling-based real-time simulation: frontend polls get_debate_status every 500ms"
  ],
  "known_issues": [
    "SwarmHealth toggle onChange handlers execute immediately on render causing infinite loops",
    "Stuck disabled buttons in SwarmHealth due to missing loading state reset in error conditions",
    "Boardroom transcript container has no min-height causing layout shifts when setTranscript([]) is called",
    "React Error 185 in Boardroom component from state setters called directly in main render body",
    "createActor fails silently without try/catch causing permanent loading screen",
    "Duplicate guard clauses in parent Layout and child components render multiple stacked loading messages simultaneously"
  ],
  "isFixRequest": true,
  "existing_features": [
    {
      "id": "feature-create-frontend-dashboard-that-displays-the-status-and-identity-of-all-9-canisters-in-the-gang-system-showing-their-principal-ids-controller-information-and-operational-status-include-visual-representation-of-the-multi-agent-architecture",
      "title": "Create frontend dashboard that displays the status and identity of all 9 canisters in The Gang system, showing their Principal IDs, controller information, and operational status. Include visual representation of the multi-agent architecture.",
      "reqIds": [
        "REQ-4"
      ],
      "version": 1
    },
    {
      "id": "feature-design-and-implement-a-creative-distinctive-visual-theme-for-the-gang-system-that-reflects-sovereignty-decentralization-and-multi-agent-coordination-use-a-cohesive-color-palette-that-avoids-blue-and-purple-with-typography-and-layout-that-conveys-technical-sophistication-and-autonomous-intelligence",
      "title": "Design and implement a creative, distinctive visual theme for The Gang system that reflects sovereignty, decentralization, and multi-agent coordination. Use a cohesive color palette that avoids blue and purple, with typography and layout that conveys technical sophistication and autonomous intelligence.",
      "reqIds": [
        "REQ-6"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-custom-react-hook-named-usedebatestatus-that-polls-the-backend-get-status-query-function-every-500-milliseconds-using-react-query",
      "title": "Create a custom React hook named useDebateStatus that polls the backend get_status query function every 500 milliseconds using React Query",
      "reqIds": [
        "REQ-28"
      ],
      "version": 1
    },
    {
      "id": "feature-build-a-react-ui-component-that-displays-the-current-speaker-field-e-g-skippy-is-analyzing-and-streams-the-transcript-text-onto-the-screen-in-real-time-as-it-updates-from-polling",
      "title": "Build a React UI component that displays the current_speaker field (e.g., 'Skippy is analyzing...') and streams the transcript text onto the screen in real-time as it updates from polling",
      "reqIds": [
        "REQ-29"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-a-push-to-talk-button-using-the-browser-s-native-speechrecognition-or-webkitspeechrecognition-api-that-captures-user-speech-when-pressed-and-released",
      "title": "Implement a 'Push to Talk' button using the browser's native SpeechRecognition (or webkitSpeechRecognition) API that captures user speech when pressed and released",
      "reqIds": [
        "REQ-30"
      ],
      "version": 1
    },
    {
      "id": "feature-when-the-user-stops-speaking-via-the-push-to-talk-button-capture-the-recognized-text-and-immediately-pass-it-to-the-backend-start-boardroom-debate-update-function",
      "title": "When the user stops speaking via the Push to Talk button, capture the recognized text and immediately pass it to the backend start_boardroom_debate update function",
      "reqIds": [
        "REQ-31"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-the-native-speechsynthesis-api-with-a-useeffect-hook-that-listens-to-changes-in-the-transcript-and-current-speaker-when-current-speaker-changes-to-robby-automatically-speak-robby-s-final-response-out-loud-using-a-british-male-voice-if-available-in-the-user-s-browser",
      "title": "Implement the native SpeechSynthesis API with a useEffect hook that listens to changes in the transcript and current_speaker. When current_speaker changes to 'Robby', automatically speak Robby's final response out loud using a British Male voice if available in the user's browser",
      "reqIds": [
        "REQ-32"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-prominent-interrupt-stop-button-on-the-ui-that-when-clicked-executes-window-speechsynthesis-cancel-to-stop-browser-speech-and-immediately-calls-the-backend-abort-debate-function-to-kill-the-inter-canister-routing",
      "title": "Create a prominent 'Interrupt/Stop' button on the UI that when clicked executes window.speechSynthesis.cancel() to stop browser speech and immediately calls the backend abort_debate function to kill the inter-canister routing",
      "reqIds": [
        "REQ-33"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-rendering-rule-for-the-transcript-output-component-if-any-text-resembles-a-product-link-it-must-strictly-be-rendered-as-an-html-anchor-tag-a-explicitly-strip-or-block-any-html-table-tags-from-rendering-in-the-ui",
      "title": "Create a rendering rule for the transcript output component. If any text resembles a product link, it must strictly be rendered as an HTML anchor tag (<a>). Explicitly strip or block any HTML <table> tags from rendering in the UI",
      "reqIds": [
        "REQ-34"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-commented-out-placeholder-hook-called-usewakewordstub-with-a-todo-comment-stating-todo-inject-picovoice-porcupine-react-logic-here-to-trigger-the-speechrecognition-automatically",
      "title": "Create a commented-out placeholder hook called useWakeWordStub with a TODO comment stating: 'TODO: Inject @picovoice/porcupine-react logic here to trigger the SpeechRecognition automatically'",
      "reqIds": [
        "REQ-35"
      ],
      "version": 1
    },
    {
      "id": "feature-integrate-the-dfinity-auth-client-package-into-the-react-frontend-and-add-a-prominent-login-with-internet-identity-button-to-the-dashboard",
      "title": "Integrate the @dfinity/auth-client package into the React frontend and add a prominent 'Login with Internet Identity' button to the dashboard",
      "reqIds": [
        "REQ-36"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-high-stakes-ui-lock-in-the-debatedisplay-component-hide-or-blur-the-transcript-output-from-robby-and-disable-the-text-to-speech-functionality-unless-the-user-is-actively-authenticated-via-internet-identity",
      "title": "Implement 'High-Stakes' UI lock in the DebateDisplay component: hide or blur the transcript output from Robby, and disable the Text-to-Speech functionality, unless the user is actively authenticated via Internet Identity",
      "reqIds": [
        "REQ-37"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-react-sensory-cortex-tab-file-ingestion-logic-use-the-filereader-api-to-read-standard-text-files-txt-csv-json-as-text-and-extract-exactly-the-first-5-000-characters-into-a-variable-named-previewstring-for-images-or-unsupported-binary-files-set-previewstring-to-binary-image-data",
      "title": "In the React 'Sensory Cortex' tab file ingestion logic, use the FileReader API to read standard text files (.txt, .csv, .json) as text and extract exactly the first 5,000 characters into a variable named previewString. For images or unsupported binary files, set previewString to 'Binary Image Data'.",
      "reqIds": [
        "REQ-52"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-react-sensory-cortex-tab-immediately-after-the-1-8mb-chunk-upload-loop-completes-100-call-the-backend-route-document-function-with-two-arguments-file-name-and-the-previewstring-extracted-in-req-52",
      "title": "In the React 'Sensory Cortex' tab, immediately after the 1.8MB chunk upload loop completes 100%, call the backend route_document function with two arguments: file.name and the previewString extracted in REQ-52.",
      "reqIds": [
        "REQ-53"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-new-react-component-for-the-sensory-cortex-ui-featuring-a-large-high-contrast-drag-and-drop-file-upload-area-for-desktop-implement-ondrop-and-ondragover-event-handlers-to-capture-dropped-files-maintain-the-technical-sophisticated-theme-using-dark-grays-sharp-edges-and-emergency-vehicle-highlight-colors-avoiding-purple-and-blue",
      "title": "Create a new React component for the Sensory Cortex UI featuring a large, high-contrast drag-and-drop file upload area. For desktop, implement onDrop and onDragOver event handlers to capture dropped files. Maintain the technical, sophisticated theme using dark grays, sharp edges, and emergency vehicle highlight colors (avoiding purple and blue).",
      "reqIds": [
        "REQ-55"
      ],
      "version": 1
    },
    {
      "id": "feature-add-a-take-photo-button-to-the-sensory-cortex-interface-using-input-type-file-accept-image-capture-environment-to-enable-mobile-camera-capture-also-add-a-select-file-button-using-a-standard-file-input-to-allow-users-to-pick-files-from-their-device-on-any-platform",
      "title": "Add a 'Take Photo' button to the Sensory Cortex interface using <input type='file' accept='image/*' capture='environment'> to enable mobile camera capture. Also add a 'Select File' button using a standard file input to allow users to pick files from their device on any platform.",
      "reqIds": [
        "REQ-56"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-a-sequential-chunking-engine-in-the-sensory-cortex-component-using-a-for-of-loop-to-handle-file-uploads-slice-each-file-into-chunks-of-exactly-1-800-000-bytes-use-await-on-each-upload-chunk-backend-call-and-do-not-send-the-next-chunk-until-the-previous-upload-is-confirmed-this-sequential-approach-prevents-wasm-heap-overflow",
      "title": "Implement a sequential chunking engine in the Sensory Cortex component using a for...of loop to handle file uploads. Slice each file into chunks of exactly 1,800,000 bytes. Use await on each upload_chunk backend call and do not send the next chunk until the previous upload is confirmed. This sequential approach prevents Wasm heap overflow.",
      "reqIds": [
        "REQ-57"
      ],
      "version": 1
    },
    {
      "id": "feature-add-a-real-time-progress-bar-to-the-sensory-cortex-interface-that-displays-the-upload-percentage-based-on-the-number-of-chunks-successfully-written-to-stable-memory-update-the-progress-bar-after-each-chunk-upload-confirms",
      "title": "Add a real-time progress bar to the Sensory Cortex interface that displays the upload percentage based on the number of chunks successfully written to Stable Memory. Update the progress bar after each chunk upload confirms.",
      "reqIds": [
        "REQ-58"
      ],
      "version": 1
    },
    {
      "id": "feature-after-a-file-upload-reaches-100-completion-in-the-sensory-cortex-interface-read-the-first-5-000-characters-of-the-uploaded-file-immediately-call-the-backend-route-document-function-with-two-arguments-the-filename-and-the-extracted-5-000-character-text-preview",
      "title": "After a file upload reaches 100% completion in the Sensory Cortex interface, read the first 5,000 characters of the uploaded file. Immediately call the backend route_document function with two arguments: the filename and the extracted 5,000-character text preview.",
      "reqIds": [
        "REQ-59"
      ],
      "version": 1
    },
    {
      "id": "feature-display-a-visual-notification-in-the-sensory-cortex-interface-after-the-route-document-call-completes-the-notification-must-show-the-message-format-document-filename-routed-to-agent-name-via-sensory-cortex-where-agent-name-is-the-value-returned-by-the-backend-routing-logic",
      "title": "Display a visual notification in the Sensory Cortex interface after the route_document call completes. The notification must show the message format: 'Document [filename] routed to [Agent Name] via Sensory Cortex' where Agent Name is the value returned by the backend routing logic.",
      "reqIds": [
        "REQ-60"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-ensure-the-sensory-cortex-tab-is-visible-and-clickable-in-the-navigation-bar-the-tab-should-be-positioned-alongside-the-boardroom-debate-tab-with-clear-visual-indication-of-which-tab-is-currently-active",
      "title": "In frontend/src/App.tsx, ensure the Sensory Cortex tab is visible and clickable in the navigation bar. The tab should be positioned alongside the Boardroom Debate tab with clear visual indication of which tab is currently active.",
      "reqIds": [
        "REQ-61"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensorycortextab-component-frontend-src-components-sensorycortextab-tsx-ensure-all-file-upload-controls-are-prominently-displayed-and-functional-the-drag-and-drop-area-must-be-large-and-visually-distinct-the-take-photo-button-must-be-visible-with-a-camera-icon-and-the-select-file-button-must-be-visible-and-accessible",
      "title": "In the SensoryCortexTab component (frontend/src/components/SensoryCortexTab.tsx), ensure all file upload controls are prominently displayed and functional: the drag-and-drop area must be large and visually distinct, the 'Take Photo' button must be visible with a camera icon, and the 'Select File' button must be visible and accessible.",
      "reqIds": [
        "REQ-62"
      ],
      "version": 1
    },
    {
      "id": "feature-add-visual-feedback-to-the-sensory-cortex-tab-button-to-indicate-when-the-sensory-cortex-interface-is-the-active-view-use-consistent-styling-that-matches-the-boardroom-tab-s-active-state-pattern",
      "title": "Add visual feedback to the Sensory Cortex tab button to indicate when the Sensory Cortex interface is the active view. Use consistent styling that matches the Boardroom tab's active state pattern.",
      "reqIds": [
        "REQ-63"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-create-a-react-state-variable-named-activetab-using-usestate-defaulting-to-the-string-value-boardroom",
      "title": "In frontend/src/App.tsx, create a React state variable named activeTab using useState, defaulting to the string value 'boardroom'",
      "reqIds": [
        "REQ-64"
      ],
      "version": 1
    },
    {
      "id": "feature-at-the-top-of-the-app-tsx-render-output-create-a-navigation-header-section-containing-three-button-elements-labeled-boardroom-sensory-cortex-and-swarm-health-that-update-the-activetab-state-to-boardroom-sensory-and-health-respectively-when-clicked",
      "title": "At the top of the App.tsx render output, create a Navigation Header section containing three button elements labeled 'Boardroom', 'Sensory Cortex', and 'Swarm Health' that update the activeTab state to 'boardroom', 'sensory', and 'health' respectively when clicked",
      "reqIds": [
        "REQ-65"
      ],
      "version": 1
    },
    {
      "id": "feature-apply-high-contrast-styling-to-the-navigation-buttons-using-the-tactical-dark-aesthetic-use-background-color-1a1a1a-for-the-navigation-bar-bright-green-39ff14-or-amber-text-color-for-active-buttons-sharp-0px-border-radius-on-all-button-elements-and-clear-visual-differentiation-between-active-and-inactive-buttons",
      "title": "Apply high-contrast styling to the navigation buttons using the tactical dark aesthetic: use background color #1a1a1a for the navigation bar, bright green (#39FF14) or amber text color for active buttons, sharp 0px border-radius on all button elements, and clear visual differentiation between active and inactive buttons",
      "reqIds": [
        "REQ-66"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-main-render-block-of-app-tsx-implement-conditional-rendering-logic-using-switch-statement-or-if-else-that-displays-the-boardroom-debate-voice-assistant-interface-when-activetab-equals-boardroom-displays-the-sensory-cortex-file-ingestion-ui-when-activetab-equals-sensory-and-displays-the-c2-dashboard-swarm-health-when-activetab-equals-health",
      "title": "In the main render block of App.tsx, implement conditional rendering logic using switch statement or if/else that displays the Boardroom Debate voice assistant interface when activeTab equals 'boardroom', displays the Sensory Cortex file ingestion UI when activeTab equals 'sensory', and displays the C2 Dashboard (Swarm Health) when activeTab equals 'health'",
      "reqIds": [
        "REQ-67"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensory-cortex-interface-create-a-large-drag-and-drop-zone-implemented-as-a-div-element-with-a-dashed-border-implement-ondrop-and-ondragover-event-handlers-to-capture-dropped-files-from-desktop-users",
      "title": "In the Sensory Cortex interface, create a large drag-and-drop zone implemented as a div element with a dashed border. Implement onDrop and onDragOver event handlers to capture dropped files from desktop users",
      "reqIds": [
        "REQ-68"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensory-cortex-interface-add-a-hidden-file-input-element-with-type-file-accept-image-capture-environment-and-id-camerainput-styled-with-display-none-create-a-large-visible-button-labeled-take-photo-that-triggers-a-click-on-the-hidden-file-input-when-pressed",
      "title": "In the Sensory Cortex interface, add a hidden file input element with type='file', accept='image/*', capture='environment', and id='cameraInput' styled with display: none. Create a large visible button labeled 'ðŸ“· TAKE PHOTO' that triggers a click on the hidden file input when pressed",
      "reqIds": [
        "REQ-69"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensory-cortex-interface-implement-a-sequential-chunking-engine-using-a-for-of-loop-that-starts-immediately-when-a-file-is-dropped-or-selected-slice-each-file-into-chunks-of-exactly-1-800-000-bytes-use-await-on-each-upload-chunk-backend-call-and-do-not-send-the-next-chunk-until-the-previous-upload-is-confirmed",
      "title": "In the Sensory Cortex interface, implement a sequential chunking engine using a for...of loop that starts immediately when a file is dropped or selected. Slice each file into chunks of exactly 1,800,000 bytes, use await on each upload_chunk backend call, and do not send the next chunk until the previous upload is confirmed",
      "reqIds": [
        "REQ-70"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensory-cortex-interface-add-a-real-time-progress-bar-element-that-displays-upload-percentage-calculated-as-currentchunk-totalchunks-100-update-the-progress-bar-after-each-chunk-upload-confirms-completion",
      "title": "In the Sensory Cortex interface, add a real-time progress bar element that displays upload percentage calculated as (currentChunk / totalChunks) * 100. Update the progress bar after each chunk upload confirms completion",
      "reqIds": [
        "REQ-71"
      ],
      "version": 1
    },
    {
      "id": "feature-apply-tactical-dark-aesthetic-styling-throughout-the-sensory-cortex-interface-use-dark-background-color-1a1a1a-bright-green-39ff14-or-amber-text-for-data-display-sharp-edges-with-0px-border-radius-on-all-elements-and-avoid-using-blue-or-purple-colors",
      "title": "Apply tactical dark aesthetic styling throughout the Sensory Cortex interface: use dark background color #1a1a1a, bright green (#39FF14) or amber text for data display, sharp edges with 0px border-radius on all elements, and avoid using blue or purple colors",
      "reqIds": [
        "REQ-72"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-new-react-component-or-section-within-the-existing-swarm-health-tab-frontend-src-app-tsx-that-displays-a-data-table-listing-all-9-ai-agents-robby-skippy-the-architect-deep-thought-glados-vincent-janet-the-librarian-and-sensory-cortex-with-their-names-prominently-displayed",
      "title": "Create a new React component or section within the existing 'Swarm Health' tab (frontend/src/App.tsx) that displays a data table listing all 9 AI agents (Robby, Skippy, The_Architect, Deep_Thought, GLaDOS, VINCENT, Janet, The_Librarian, and Sensory_Cortex) with their names prominently displayed",
      "reqIds": [
        "REQ-76"
      ],
      "version": 1
    },
    {
      "id": "feature-add-a-toggle-switch-ui-component-next-to-each-agent-in-the-swarm-health-data-table-that-triggers-the-backend-toggle-agent-status-function-when-clicked-the-toggle-must-pass-the-agent-s-name-and-the-new-enabled-disabled-status-to-the-backend-function",
      "title": "Add a Toggle/Switch UI component next to each agent in the Swarm Health data table that triggers the backend toggle_agent_status function when clicked. The toggle must pass the agent's name and the new enabled/disabled status to the backend function.",
      "reqIds": [
        "REQ-77"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-visual-status-indicators-in-the-swarm-health-agent-table-use-a-green-indicator-color-39ff14-for-enabled-agents-and-a-red-indicator-for-disabled-agents-the-indicator-should-be-clearly-visible-and-update-in-real-time-based-on-the-agent-s-is-enabled-status",
      "title": "Implement visual status indicators in the Swarm Health agent table: use a green indicator (color #39FF14) for enabled agents and a red indicator for disabled agents. The indicator should be clearly visible and update in real-time based on the agent's is_enabled status.",
      "reqIds": [
        "REQ-78"
      ],
      "version": 1
    },
    {
      "id": "feature-create-a-react-query-mutation-hook-in-frontend-src-hooks-usequeries-ts-for-the-toggle-agent-status-backend-function-that-accepts-agent-name-and-status-parameters-and-invalidates-the-agent-status-query-after-successful-execution",
      "title": "Create a React Query mutation hook in frontend/src/hooks/useQueries.ts for the toggle_agent_status backend function that accepts agent_name and status parameters and invalidates the agent status query after successful execution",
      "reqIds": [
        "REQ-79"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensorycortextab-component-frontend-src-components-sensorycortextab-tsx-diagnose-and-fix-the-file-upload-flow-so-that-when-a-user-drags-a-file-into-the-drag-and-drop-zone-or-uses-the-select-file-button-clicking-the-upload-file-button-successfully-triggers-the-sequential-chunking-engine-and-begins-uploading-to-the-backend",
      "title": "In the SensoryCortexTab component (frontend/src/components/SensoryCortexTab.tsx), diagnose and fix the file upload flow so that when a user drags a file into the drag-and-drop zone OR uses the 'Select File' button, clicking the 'Upload File' button successfully triggers the sequential chunking engine and begins uploading to the backend",
      "reqIds": [
        "REQ-80"
      ],
      "version": 1
    },
    {
      "id": "feature-ensure-the-file-state-management-in-sensorycortextab-correctly-captures-and-stores-the-selected-file-from-both-the-drag-and-drop-ondrop-handler-and-the-file-input-onchange-handler-so-that-the-file-is-available-when-the-upload-file-button-click-event-fires",
      "title": "Ensure the file state management in SensoryCortexTab correctly captures and stores the selected file from both the drag-and-drop onDrop handler and the file input onChange handler, so that the file is available when the 'Upload File' button click event fires",
      "reqIds": [
        "REQ-81"
      ],
      "version": 1
    },
    {
      "id": "feature-verify-that-the-upload-file-button-in-sensorycortextab-has-a-proper-onclick-handler-that-reads-the-stored-file-from-state-and-invokes-the-sequential-chunking-upload-logic-if-the-handler-is-missing-or-incorrectly-wired-implement-or-fix-it",
      "title": "Verify that the 'Upload File' button in SensoryCortexTab has a proper onClick handler that reads the stored file from state and invokes the sequential chunking upload logic. If the handler is missing or incorrectly wired, implement or fix it",
      "reqIds": [
        "REQ-82"
      ],
      "version": 1
    },
    {
      "id": "feature-add-console-logging-or-visual-feedback-in-the-sensorycortextab-upload-flow-to-help-diagnose-state-issues-log-when-file-is-captured-from-drag-and-drop-when-file-is-captured-from-file-input-and-when-upload-file-button-is-clicked-display-error-message-to-user-if-upload-file-button-is-clicked-with-no-file-selected",
      "title": "Add console logging or visual feedback in the SensoryCortexTab upload flow to help diagnose state issues: log when file is captured from drag-and-drop, when file is captured from file input, and when Upload File button is clicked. Display error message to user if Upload File button is clicked with no file selected",
      "reqIds": [
        "REQ-83"
      ],
      "version": 1
    },
    {
      "id": "feature-delete-the-entire-sensory-cortex-canister-principal-input-field-and-its-associated-state-variable-from-the-sensorycortextab-component-frontend-src-components-sensorycortextab-tsx",
      "title": "Delete the entire 'SENSORY CORTEX CANISTER PRINCIPAL' input field and its associated state variable from the SensoryCortexTab component (frontend/src/components/SensoryCortexTab.tsx)",
      "reqIds": [
        "REQ-84"
      ],
      "version": 1
    },
    {
      "id": "feature-remove-all-validation-logic-that-disables-the-start-upload-button-based-on-a-principal-id-the-only-requirement-for-the-start-upload-button-to-be-active-is-that-a-file-is-selected-if-selectedfile-null",
      "title": "Remove all validation logic that disables the 'START UPLOAD' button based on a Principal ID. The ONLY requirement for the 'START UPLOAD' button to be active is that a file is selected (if (selectedFile !== null))",
      "reqIds": [
        "REQ-85"
      ],
      "version": 1
    },
    {
      "id": "feature-fix-the-upload-flow-so-that-when-start-upload-is-clicked-the-chunking-loop-sends-1-8mb-chunks-directly-to-the-backend-orchestrator-s-upload-chunk-function-not-to-sensory-cortex-directly",
      "title": "Fix the upload flow so that when 'START UPLOAD' is clicked, the chunking loop sends 1.8MB chunks directly to the backend Orchestrator's upload_chunk function (not to Sensory Cortex directly)",
      "reqIds": [
        "REQ-86"
      ],
      "version": 1
    },
    {
      "id": "feature-when-the-upload-reaches-100-completion-call-the-backend-orchestrator-s-route-document-file-name-previewtext-function-where-previewtext-is-the-first-5-000-characters-extracted-from-the-file",
      "title": "When the upload reaches 100% completion, call the backend Orchestrator's route_document(file.name, previewText) function where previewText is the first 5,000 characters extracted from the file",
      "reqIds": [
        "REQ-87"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-sensorycortextab-tsx-ensure-the-backend-actor-is-properly-imported-and-available-in-component-scope-if-the-app-uses-useactor-hook-or-actorprovider-context-destructure-the-backend-actor-from-it-at-the-top-of-the-component-function",
      "title": "In frontend/src/components/SensoryCortexTab.tsx, ensure the backend actor is properly imported and available in component scope. If the app uses useActor() hook or ActorProvider context, destructure the backend actor from it at the top of the component function.",
      "reqIds": [
        "REQ-88"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-ensure-the-backend-actor-is-properly-imported-and-available-in-component-scope-if-the-app-uses-useactor-hook-or-actorprovider-context-destructure-the-backend-actor-from-it-at-the-top-of-the-component-function",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, ensure the backend actor is properly imported and available in component scope. If the app uses useActor() hook or ActorProvider context, destructure the backend actor from it at the top of the component function.",
      "reqIds": [
        "REQ-89"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-sensorycortextab-tsx-add-a-guard-clause-at-the-beginning-of-the-component-render-logic-that-checks-if-backend-is-null-or-undefined-if-backend-is-not-initialized-return-early-with-a-loading-message-div-initializing-connection-to-the-orchestrator-div",
      "title": "In frontend/src/components/SensoryCortexTab.tsx, add a guard clause at the beginning of the component render logic that checks if backend is null or undefined. If backend is not initialized, return early with a loading message: <div>Initializing connection to The Orchestrator...</div>",
      "reqIds": [
        "REQ-90"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-add-a-guard-clause-at-the-beginning-of-the-component-render-logic-that-checks-if-backend-is-null-or-undefined-if-backend-is-not-initialized-return-early-with-a-loading-message-div-initializing-connection-to-the-orchestrator-div",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, add a guard clause at the beginning of the component render logic that checks if backend is null or undefined. If backend is not initialized, return early with a loading message: <div>Initializing connection to The Orchestrator...</div>",
      "reqIds": [
        "REQ-91"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-handleupload-function-within-frontend-src-components-sensorycortextab-tsx-ensure-the-initialized-backend-actor-is-properly-accessible-and-used-for-all-backend-upload-chunk-calls-during-the-sequential-chunking-loop-verify-that-the-backend-variable-is-in-scope-and-not-shadowed-or-undefined-when-handleupload-executes",
      "title": "In the handleUpload function within frontend/src/components/SensoryCortexTab.tsx, ensure the initialized backend actor is properly accessible and used for all backend.upload_chunk() calls during the sequential chunking loop. Verify that the backend variable is in scope and not shadowed or undefined when handleUpload executes.",
      "reqIds": [
        "REQ-92"
      ],
      "version": 1
    },
    {
      "id": "feature-add-error-handling-in-both-frontend-src-components-sensorycortextab-tsx-and-frontend-src-components-agentregistrytable-tsx-to-gracefully-handle-cases-where-the-backend-actor-initialization-fails-display-a-user-friendly-error-message-if-the-actor-remains-uninitialized-after-a-reasonable-timeout-or-initialization-attempt",
      "title": "Add error handling in both frontend/src/components/SensoryCortexTab.tsx and frontend/src/components/AgentRegistryTable.tsx to gracefully handle cases where the backend actor initialization fails. Display a user-friendly error message if the actor remains uninitialized after a reasonable timeout or initialization attempt.",
      "reqIds": [
        "REQ-93"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-import-the-backend-actor-using-the-useactor-hook-create-a-react-state-variable-using-usestate-with-signature-const-agents-setagents-usestate-any-to-store-the-agent-list",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, import the backend actor using the useActor hook, create a React state variable using useState with signature const [agents, setAgents] = useState<any[]>([]) to store the agent list",
      "reqIds": [
        "REQ-96"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-implement-a-useeffect-hook-that-runs-on-component-mount-calls-await-backend-get-agent-registry-and-updates-the-agents-state-with-the-returned-data-using-setagents",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, implement a useEffect hook that runs on component mount, calls await backend.get_agent_registry(), and updates the agents state with the returned data using setAgents",
      "reqIds": [
        "REQ-97"
      ],
      "version": 1
    },
    {
      "id": "feature-refactor-the-table-rendering-logic-in-frontend-src-components-agentregistrytable-tsx-to-dynamically-generate-rows-by-mapping-over-the-agents-state-array-instead-of-using-hardcoded-html-each-row-must-display-the-agent-s-name-and-current-status",
      "title": "Refactor the table rendering logic in frontend/src/components/AgentRegistryTable.tsx to dynamically generate rows by mapping over the agents state array instead of using hardcoded HTML. Each row must display the agent's name and current status",
      "reqIds": [
        "REQ-98"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-update-each-toggle-component-in-the-mapped-table-rows-to-reflect-the-true-agent-is-enabled-boolean-value-from-the-backend-state-showing-enabled-state-when-is-enabled-is-true-and-disabled-state-when-is-enabled-is-false",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, update each Toggle component in the mapped table rows to reflect the true agent.is_enabled boolean value from the backend state, showing enabled state when is_enabled is true and disabled state when is_enabled is false",
      "reqIds": [
        "REQ-99"
      ],
      "version": 1
    },
    {
      "id": "feature-add-an-onchange-or-onclick-event-handler-to-each-toggle-component-in-frontend-src-components-agentregistrytable-tsx-that-executes-await-backend-toggle-agent-status-agent-name-agent-is-enabled-when-the-toggle-is-clicked-passing-the-agent-s-name-and-the-inverted-enabled-status",
      "title": "Add an onChange or onClick event handler to each Toggle component in frontend/src/components/AgentRegistryTable.tsx that executes await backend.toggle_agent_status(agent.name, !agent.is_enabled) when the toggle is clicked, passing the agent's name and the inverted enabled status",
      "reqIds": [
        "REQ-100"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-after-the-toggle-agent-status-backend-call-resolves-successfully-immediately-call-backend-get-agent-registry-again-to-fetch-the-updated-agent-data-from-the-backend-and-call-setagents-with-the-fresh-data-to-update-the-ui-state-in-real-time",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, after the toggle_agent_status backend call resolves successfully, immediately call backend.get_agent_registry() again to fetch the updated agent data from the backend and call setAgents with the fresh data to update the UI state in real-time",
      "reqIds": [
        "REQ-101"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-debatedisplay-tsx-remove-the-text-authentication-required-to-view-robby-s-responses-and-enable-text-to-speech-from-the-component-render-output",
      "title": "In frontend/src/components/DebateDisplay.tsx, remove the text 'Authentication required to view Robby's responses and enable Text-to-Speech.' from the component render output",
      "reqIds": [
        "REQ-110"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-debatedisplay-tsx-remove-all-conditional-logic-that-blurs-hides-or-blocks-the-transcript-output-based-on-authentication-state-the-transcript-must-always-be-fully-visible-and-readable-when-the-boardroom-tab-is-active",
      "title": "In frontend/src/components/DebateDisplay.tsx, remove all conditional logic that blurs, hides, or blocks the transcript output based on authentication state. The transcript must always be fully visible and readable when the Boardroom tab is active",
      "reqIds": [
        "REQ-111"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-debatedisplay-tsx-remove-all-conditional-logic-that-disables-or-prevents-the-text-to-speech-functionality-based-on-authentication-state-the-speechsynthesis-api-must-function-for-all-users-viewing-the-boardroom-tab",
      "title": "In frontend/src/components/DebateDisplay.tsx, remove all conditional logic that disables or prevents the Text-to-Speech functionality based on authentication state. The SpeechSynthesis API must function for all users viewing the Boardroom tab",
      "reqIds": [
        "REQ-112"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-or-the-component-managing-boardroom-state-ensure-all-state-variables-controlling-the-push-to-talk-button-such-as-isrecording-isdebating-or-islistening-are-strictly-initialized-to-false-using-usestate-false-the-button-must-default-to-displaying-push-to-talk-on-initial-render",
      "title": "In frontend/src/App.tsx or the component managing Boardroom state, ensure all state variables controlling the Push to Talk button (such as isRecording, isDebating, or isListening) are strictly initialized to false using useState(false). The button must default to displaying 'Push to Talk' on initial render.",
      "reqIds": [
        "REQ-116"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-speech-recognition-event-handler-onresult-or-onend-callback-or-the-function-that-calls-backend-start-boardroom-debate-wrap-the-entire-execution-block-in-a-try-catch-statement-if-the-backend-call-fails-or-throws-an-error-catch-it-using-console-error-to-log-the-error-and-append-the-text-system-error-backend-connection-failed-to-the-transcript-state-variable-to-provide-user-feedback",
      "title": "In the Speech Recognition event handler (onResult or onEnd callback) or the function that calls backend.start_boardroom_debate, wrap the entire execution block in a try/catch statement. If the backend call fails or throws an error, catch it using console.error to log the error, and append the text 'System Error: Backend connection failed.' to the transcript state variable to provide user feedback.",
      "reqIds": [
        "REQ-117"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-the-component-that-renders-the-boardroom-debate-interface-add-a-guard-clause-at-the-very-beginning-of-the-component-render-function-check-if-the-backend-actor-is-null-or-undefined-using-if-backend-if-the-backend-actor-is-not-initialized-return-early-with-a-simple-loading-indicator-div-connecting-to-the-gang-div-do-not-render-the-full-boardroom-ui-buttons-or-any-interactive-elements-until-the-backend-connection-is-confirmed",
      "title": "In the Boardroom component (frontend/src/App.tsx or the component that renders the Boardroom debate interface), add a guard clause at the very beginning of the component render function. Check if the backend actor is null or undefined using if (!backend). If the backend actor is not initialized, return early with a simple loading indicator: <div>Connecting to The Gang...</div>. Do not render the full Boardroom UI, buttons, or any interactive elements until the backend connection is confirmed.",
      "reqIds": [
        "REQ-118"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-the-component-managing-debate-state-locate-the-async-function-that-calls-backend-start-boardroom-debate-this-function-should-already-have-a-try-catch-block-for-error-handling-add-a-finally-block-after-the-catch-block-inside-the-finally-block-explicitly-reset-all-loading-state-variables-to-false-this-must-include-setisdebating-false-and-setisrecording-false-or-any-equivalent-state-setters-that-control-button-disabled-states-the-finally-block-ensures-buttons-re-enable-even-if-the-backend-call-fails-or-throws-an-error",
      "title": "In the Boardroom component (frontend/src/App.tsx or the component managing debate state), locate the async function that calls backend.start_boardroom_debate. This function should already have a try/catch block for error handling. Add a finally block after the catch block. Inside the finally block, explicitly reset all loading state variables to false. This must include setIsDebating(false) and setIsRecording(false), or any equivalent state setters that control button disabled states. The finally block ensures buttons re-enable even if the backend call fails or throws an error.",
      "reqIds": [
        "REQ-119"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-wherever-the-boardroom-debate-interface-is-rendered-locate-the-backend-actor-import-initialization-logic-replace-any-local-const-backend-declarations-with-the-exact-same-pattern-used-by-swarmhealth-and-sensorycortex-components-to-access-the-backend-actor-from-the-global-auth-context-e-g-const-backend-useactor-or-destructuring-from-authcontext-useauth-hook",
      "title": "In the Boardroom component (frontend/src/App.tsx or wherever the Boardroom debate interface is rendered), locate the backend actor import/initialization logic. Replace any local const backend declarations with the exact same pattern used by SwarmHealth and SensoryCortex components to access the backend actor from the global Auth context (e.g., const { backend } = useActor() or destructuring from AuthContext/useAuth hook).",
      "reqIds": [
        "REQ-120"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-render-logic-remove-or-replace-any-dead-local-variable-declarations-such-as-const-backend-null-or-backend-undefined-that-prevent-the-component-from-accessing-the-live-global-backend-actor-ensure-the-backend-variable-is-exclusively-sourced-from-the-global-auth-state-context-and-is-never-locally-overridden-to-null-or-undefined",
      "title": "In the Boardroom component render logic, remove or replace any dead local variable declarations such as const backend = null; or backend = undefined that prevent the component from accessing the live global backend actor. Ensure the backend variable is exclusively sourced from the global Auth state/context and is never locally overridden to null or undefined.",
      "reqIds": [
        "REQ-121"
      ],
      "version": 1
    },
    {
      "id": "feature-ensure-the-boardroom-component-re-renders-automatically-when-the-global-auth-state-initializes-the-backend-actor-verify-that-the-component-s-guard-clause-if-backend-correctly-evaluates-the-live-backend-state-and-drops-the-connecting-to-the-gang-loading-screen-the-moment-the-backend-actor-becomes-available-from-the-global-context",
      "title": "Ensure the Boardroom component re-renders automatically when the global Auth state initializes the backend actor. Verify that the component's guard clause (if (!backend)) correctly evaluates the live backend state and drops the 'Connecting to The Gang...' loading screen the moment the backend actor becomes available from the global context.",
      "reqIds": [
        "REQ-122"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-the-component-rendering-the-boardroom-interface-import-and-destructure-three-values-from-the-useauth-hook-or-authprovider-context-isauthenticated-boolean-backend-actor-instance-and-isloading-or-equivalent-loading-state-variable-that-signals-the-auth-system-is-still-initializing-the-session",
      "title": "In the Boardroom component (frontend/src/App.tsx or the component rendering the Boardroom interface), import and destructure three values from the useAuth hook or AuthProvider context: isAuthenticated (boolean), backend (Actor instance), and isLoading (or equivalent loading state variable that signals the auth system is still initializing the session)",
      "reqIds": [
        "REQ-123"
      ],
      "version": 1
    },
    {
      "id": "feature-implement-strict-conditional-rendering-order-in-the-boardroom-component-with-four-distinct-states-1-if-isloading-is-true-display-a-generic-loading-spinner-or-message-2-if-isloading-is-false-and-isauthenticated-is-false-display-the-sign-in-with-internet-identity-button-3-if-isloading-is-false-and-isauthenticated-is-true-and-backend-is-null-or-undefined-display-initializing-backend-message-4-only-render-the-full-push-to-talk-ui-and-debate-interface-if-isloading-is-false-and-isauthenticated-is-true-and-backend-is-not-null",
      "title": "Implement strict conditional rendering order in the Boardroom component with four distinct states: (1) If isLoading is true, display a generic loading spinner or message. (2) If isLoading is false AND isAuthenticated is false, display the 'Sign in with Internet Identity' button. (3) If isLoading is false AND isAuthenticated is true AND backend is null or undefined, display 'Initializing Backend...' message. (4) ONLY render the full Push-to-Talk UI and debate interface if isLoading is false AND isAuthenticated is true AND backend is NOT null",
      "reqIds": [
        "REQ-124"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-handlespeech-function-or-any-function-in-the-boardroom-component-that-calls-backend-start-boardroom-debate-or-other-backend-methods-add-a-guard-clause-at-the-very-beginning-if-backend-return-this-prevents-the-actor-not-initialized-crash-if-the-user-clicks-a-button-before-the-actor-is-fully-ready",
      "title": "In the handleSpeech function or any function in the Boardroom component that calls backend.start_boardroom_debate or other backend methods, add a guard clause at the very beginning: if (!backend) return;. This prevents the 'Actor not initialized' crash if the user clicks a button before the actor is fully ready",
      "reqIds": [
        "REQ-125"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-wherever-the-push-to-talk-button-handler-is-implemented-add-settranscript-at-the-very-beginning-of-the-function-that-triggers-speech-recognition-this-clears-the-transcript-state-immediately-when-the-user-presses-push-to-talk-ensuring-each-new-recording-starts-with-a-fresh-empty-transcript-window",
      "title": "In the Boardroom component (frontend/src/App.tsx or wherever the Push-to-Talk button handler is implemented), add setTranscript([]) at the very beginning of the function that triggers speech recognition. This clears the transcript state immediately when the user presses Push-to-Talk, ensuring each new recording starts with a fresh, empty transcript window.",
      "reqIds": [
        "REQ-127"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-or-the-component-containing-the-handlepushtotalk-function-wrap-the-await-backend-start-boardroom-debate-call-in-a-try-catch-finally-block-in-the-catch-block-log-the-error-using-console-error-and-append-system-error-backend-connection-failed-to-the-transcript-state-in-the-finally-block-explicitly-reset-setisdebating-false-and-setisrecording-false-to-unlock-the-buttons-ensuring-this-happens-even-if-the-backend-call-throws-an-error",
      "title": "In frontend/src/App.tsx or the component containing the handlePushToTalk function, wrap the await backend.start_boardroom_debate() call in a try/catch/finally block. In the catch block, log the error using console.error() and append 'System Error: Backend connection failed.' to the transcript state. In the finally block, explicitly reset setIsDebating(false) and setIsRecording(false) to unlock the buttons, ensuring this happens even if the backend call throws an error.",
      "reqIds": [
        "REQ-129"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-or-the-component-containing-the-handlepushtotalk-function-add-settranscript-as-the-very-first-line-of-the-function-before-any-other-logic-executes-this-clears-the-transcript-state-immediately-when-the-user-presses-push-to-talk-ensuring-each-new-recording-starts-with-a-completely-empty-transcript-window",
      "title": "In frontend/src/App.tsx or the component containing the handlePushToTalk function, add setTranscript([]) as the very first line of the function before any other logic executes. This clears the transcript state immediately when the user presses Push-to-Talk, ensuring each new recording starts with a completely empty transcript window.",
      "reqIds": [
        "REQ-130"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-wrap-the-await-backend-start-boardroom-debate-call-in-a-try-catch-finally-block-in-the-catch-block-log-the-error-using-console-error-and-append-system-error-backend-connection-failed-to-the-transcript-state-in-the-finally-block-explicitly-reset-setisdebating-false-and-setisrecording-false-to-unlock-the-buttons-ensuring-this-happens-even-if-the-backend-call-throws-an-error",
      "title": "In frontend/src/App.tsx, wrap the await backend.start_boardroom_debate() call in a try/catch/finally block. In the catch block, log the error using console.error() and append 'System Error: Backend connection failed.' to the transcript state. In the finally block, explicitly reset setIsDebating(false) and setIsRecording(false) to unlock the buttons, ensuring this happens even if the backend call throws an error.",
      "reqIds": [
        "REQ-132"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-verify-that-the-backend-actor-is-imported-using-the-same-pattern-as-swarmhealth-and-sensorycortex-components-the-backend-must-be-destructured-from-the-useactor-hook-or-authprovider-context-at-the-top-of-the-component-function-remove-any-local-const-backend-null-declarations-that-shadow-the-global-actor",
      "title": "In frontend/src/App.tsx, verify that the backend actor is imported using the same pattern as SwarmHealth and SensoryCortex components. The backend must be destructured from the useActor() hook or AuthProvider context at the top of the component function. Remove any local const backend = null declarations that shadow the global actor.",
      "reqIds": [
        "REQ-133"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-at-the-very-beginning-of-the-handlepushtotalk-function-or-equivalent-function-that-triggers-speech-recognition-add-settranscript-as-the-first-line-before-any-other-logic-executes-this-clears-the-transcript-state-immediately-when-the-user-presses-push-to-talk-ensuring-each-new-recording-starts-with-a-completely-empty-transcript-window",
      "title": "In frontend/src/App.tsx, at the very beginning of the handlePushToTalk function (or equivalent function that triggers speech recognition), add setTranscript([]) as the first line before any other logic executes. This clears the transcript state immediately when the user presses Push-to-Talk, ensuring each new recording starts with a completely empty transcript window.",
      "reqIds": [
        "REQ-134"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-debatedisplay-tsx-or-frontend-src-app-tsx-wherever-authentication-required-text-appears-search-for-and-permanently-delete-all-hardcoded-strings-containing-authentication-required-to-view-robby-s-responses-or-authentication-required-from-the-component-render-output-these-strings-must-not-exist-anywhere-in-the-boardroom-ui",
      "title": "In frontend/src/components/DebateDisplay.tsx or frontend/src/App.tsx (wherever 'Authentication required' text appears), search for and permanently delete all hardcoded strings containing 'Authentication required to view Robby's responses' or 'Authentication Required' from the component render output. These strings must not exist anywhere in the Boardroom UI.",
      "reqIds": [
        "REQ-135"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-locate-all-toggle-or-switch-component-onchange-handlers-replace-any-direct-function-call-syntax-like-onchange-handletoggle-agent-id-with-arrow-function-syntax-onchange-handletoggle-agent-id-to-prevent-immediate-execution-on-render",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, locate all Toggle or Switch component onChange handlers. Replace any direct function call syntax like onChange={handleToggle(agent.id)} with arrow function syntax onChange={() => handleToggle(agent.id)} to prevent immediate execution on render.",
      "reqIds": [
        "REQ-147"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-components-agentregistrytable-tsx-wrap-the-backend-toggle-agent-status-call-inside-the-handletoggle-function-with-a-try-catch-finally-block-in-the-finally-block-explicitly-reset-any-loading-state-variable-e-g-setupdatingid-null-or-setisloading-false-to-ensure-toggle-buttons-unlock-even-if-the-backend-call-fails-or-throws-an-error",
      "title": "In frontend/src/components/AgentRegistryTable.tsx, wrap the backend toggle_agent_status call inside the handleToggle function with a try/catch/finally block. In the finally block, explicitly reset any loading state variable (e.g., setUpdatingId(null) or setIsLoading(false)) to ensure toggle buttons unlock even if the backend call fails or throws an error.",
      "reqIds": [
        "REQ-148"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-locate-the-root-component-return-statement-move-all-guard-clauses-that-check-backend-initialization-status-backend-authentication-status-isauthenticated-or-loading-state-isloading-below-the-header-navbar-render-the-header-component-containing-the-internet-identity-login-logout-button-must-always-render-at-the-top-of-the-page-regardless-of-auth-or-backend-status",
      "title": "In frontend/src/App.tsx, locate the root component return statement. Move all guard clauses that check backend initialization status (!backend), authentication status (!isAuthenticated), or loading state (isLoading) BELOW the Header/Navbar render. The Header component containing the Internet Identity Login/Logout button MUST ALWAYS RENDER at the top of the page, regardless of auth or backend status.",
      "reqIds": [
        "REQ-151"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-refactor-the-conditional-rendering-logic-so-that-error-messages-like-failed-to-connect-to-backend-please-log-in-or-connecting-only-render-inside-the-main-content-main-area-positioned-below-the-header-navbar-these-messages-must-not-prevent-the-header-from-rendering",
      "title": "In frontend/src/App.tsx, refactor the conditional rendering logic so that error messages like 'Failed to connect to backend', 'Please log in', or 'Connecting...' only render inside the main content <main> area, positioned below the Header/Navbar. These messages must NOT prevent the header from rendering.",
      "reqIds": [
        "REQ-152"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-implement-graceful-degradation-in-the-auth-hook-error-handling-if-the-backend-actor-fails-to-initialize-wrap-the-failure-in-a-try-catch-block-and-set-a-local-error-state-variable-display-the-error-message-in-the-content-area-while-keeping-the-header-and-login-button-functional-the-app-must-not-crash-or-hide-critical-ui-elements-when-backend-initialization-fails",
      "title": "In frontend/src/App.tsx, implement graceful degradation in the Auth hook error handling. If the backend actor fails to initialize, wrap the failure in a try/catch block and set a local error state variable. Display the error message in the content area while keeping the Header and Login button functional. The app must not crash or hide critical UI elements when backend initialization fails.",
      "reqIds": [
        "REQ-153"
      ],
      "version": 1
    },
    {
      "id": "feature-in-frontend-src-app-tsx-ensure-the-authentication-flow-allows-users-to-click-the-internet-identity-login-button-and-complete-authentication-even-when-the-backend-actor-has-not-yet-initialized-the-login-flow-must-be-independent-of-backend-status-after-successful-authentication-the-backend-actor-can-initialize-asynchronously",
      "title": "In frontend/src/App.tsx, ensure the authentication flow allows users to click the Internet Identity Login button and complete authentication even when the backend actor has not yet initialized. The login flow must be independent of backend status. After successful authentication, the backend actor can initialize asynchronously.",
      "reqIds": [
        "REQ-154"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-frontend-src-app-tsx-or-the-component-that-renders-the-boardroom-interface-replace-all-existing-conditional-rendering-logic-with-strict-early-returns-in-this-exact-order-1-if-isloading-return-div-classname-p-8-text-center-text-green-500-checking-session-div-2-if-isauthenticated-return-div-classname-p-8-text-center-text-yellow-500-please-authenticate-to-continue-div-3-if-backend-return-div-classname-p-8-text-center-text-blue-500-connecting-to-the-orchestrator-div-4-return-main-ui-inside-a-fragment-or-main-div",
      "title": "In the Boardroom component (frontend/src/App.tsx or the component that renders the Boardroom interface), replace all existing conditional rendering logic with strict early returns in this exact order: (1) if (isLoading) return <div className=\"p-8 text-center text-green-500\">Checking session...</div>; (2) if (!isAuthenticated) return <div className=\"p-8 text-center text-yellow-500\">Please authenticate to continue.</div>; (3) if (!backend) return <div className=\"p-8 text-center text-blue-500\">Connecting to The Orchestrator...</div>; (4) return ( /* Main UI inside a fragment or main div */ );",
      "reqIds": [
        "REQ-157"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-swarmhealth-component-frontend-src-app-tsx-or-wherever-the-swarm-health-agent-table-is-rendered-replace-all-existing-conditional-rendering-logic-with-strict-early-returns-in-this-exact-order-1-if-isloading-return-div-classname-p-8-text-center-text-green-500-checking-session-div-2-if-isauthenticated-return-div-classname-p-8-text-center-text-yellow-500-please-authenticate-to-continue-div-3-if-backend-return-div-classname-p-8-text-center-text-blue-500-connecting-to-the-orchestrator-div-4-return-main-ui-inside-a-fragment-or-main-div",
      "title": "In the SwarmHealth component (frontend/src/App.tsx or wherever the Swarm Health agent table is rendered), replace all existing conditional rendering logic with strict early returns in this exact order: (1) if (isLoading) return <div className=\"p-8 text-center text-green-500\">Checking session...</div>; (2) if (!isAuthenticated) return <div className=\"p-8 text-center text-yellow-500\">Please authenticate to continue.</div>; (3) if (!backend) return <div className=\"p-8 text-center text-blue-500\">Connecting to The Orchestrator...</div>; (4) return ( /* Main UI inside a fragment or main div */ );",
      "reqIds": [
        "REQ-158"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-main-layout-component-frontend-src-app-tsx-locate-and-delete-all-guard-clauses-that-check-backend-initialization-status-backend-or-authentication-loading-state-isloading-the-main-app-tsx-layout-must-not-render-any-loading-spinners-connecting-messages-or-error-screens-itself-the-layout-should-only-render-the-header-navbar-component-and-the-main-content-area-routing-tabs",
      "title": "In the main layout component (frontend/src/App.tsx), locate and DELETE ALL guard clauses that check backend initialization status (!backend) or authentication loading state (isLoading). The main App.tsx layout must NOT render any loading spinners, 'Connecting...' messages, or error screens itself. The layout should ONLY render the Header/Navbar component and the main content area (routing/tabs).",
      "reqIds": [
        "REQ-161"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-boardroom-component-within-frontend-src-app-tsx-or-a-separate-boardroom-component-file-implement-strict-early-return-pattern-at-the-very-top-of-the-component-render-function-in-this-exact-order-1-if-isloading-return-div-classname-mt-10-text-center-text-green-500-checking-session-div-2-if-isauthenticated-return-div-classname-mt-10-text-center-text-yellow-500-please-authenticate-div-3-if-backend-return-div-classname-mt-10-text-center-text-red-500-actor-missing-check-console-for-errors-div-4-return-the-main-boardroom-ui-these-early-returns-must-be-the-only-conditional-rendering-logic-in-the-component",
      "title": "In the Boardroom component (within frontend/src/App.tsx or a separate Boardroom component file), implement strict early return pattern at the very top of the component render function in this exact order: (1) if (isLoading) return <div className=\"mt-10 text-center text-green-500\">Checking session...</div>; (2) if (!isAuthenticated) return <div className=\"mt-10 text-center text-yellow-500\">Please authenticate.</div>; (3) if (!backend) return <div className=\"mt-10 text-center text-red-500\">Actor missing. Check console for errors.</div>; (4) return the main Boardroom UI. These early returns must be the ONLY conditional rendering logic in the component.",
      "reqIds": [
        "REQ-162"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-swarmhealth-component-within-frontend-src-app-tsx-or-a-separate-swarmhealth-component-file-implement-strict-early-return-pattern-at-the-very-top-of-the-component-render-function-in-this-exact-order-1-if-isloading-return-div-classname-mt-10-text-center-text-green-500-checking-session-div-2-if-isauthenticated-return-div-classname-mt-10-text-center-text-yellow-500-please-authenticate-div-3-if-backend-return-div-classname-mt-10-text-center-text-red-500-actor-missing-check-console-for-errors-div-4-return-the-main-swarmhealth-ui-these-early-returns-must-be-the-only-conditional-rendering-logic-in-the-component",
      "title": "In the SwarmHealth component (within frontend/src/App.tsx or a separate SwarmHealth component file), implement strict early return pattern at the very top of the component render function in this exact order: (1) if (isLoading) return <div className=\"mt-10 text-center text-green-500\">Checking session...</div>; (2) if (!isAuthenticated) return <div className=\"mt-10 text-center text-yellow-500\">Please authenticate.</div>; (3) if (!backend) return <div className=\"mt-10 text-center text-red-500\">Actor missing. Check console for errors.</div>; (4) return the main SwarmHealth UI. These early returns must be the ONLY conditional rendering logic in the component.",
      "reqIds": [
        "REQ-163"
      ],
      "version": 1
    },
    {
      "id": "feature-in-the-sensorycortex-component-within-frontend-src-app-tsx-or-frontend-src-components-sensorycortextab-tsx-implement-strict-early-return-pattern-at-the-very-top-of-the-component-render-function-in-this-exact-order-1-if-isloading-return-div-classname-mt-10-text-center-text-green-500-checking-session-div-2-if-isauthenticated-return-div-classname-mt-10-text-center-text-yellow-500-please-authenticate-div-3-if-backend-return-div-classname-mt-10-text-center-text-red-500-actor-missing-check-console-for-errors-div-4-return-the-main-sensorycortex-ui-these-early-returns-must-be-the-only-conditional-rendering-logic-in-the-component",
      "title": "In the SensoryCortex component (within frontend/src/App.tsx or frontend/src/components/SensoryCortexTab.tsx), implement strict early return pattern at the very top of the component render function in this exact order: (1) if (isLoading) return <div className=\"mt-10 text-center text-green-500\">Checking session...</div>; (2) if (!isAuthenticated) return <div className=\"mt-10 text-center text-yellow-500\">Please authenticate.</div>; (3) if (!backend) return <div className=\"mt-10 text-center text-red-500\">Actor missing. Check console for errors.</div>; (4) return the main SensoryCortex UI. These early returns must be the ONLY conditional rendering logic in the component.",
      "reqIds": [
        "REQ-164"
      ],
      "version": 1
    }
  ],
  "new_feature_requests": [
    {
      "id": "AR-1",
      "summary": "Create 8 AI agent canisters for The Gang multi-agent system",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-2",
      "summary": "Create 1 ingestion canister for data processing",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-3",
      "summary": "Implement Principal ID-based canister control for strict sovereignty",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-4",
      "summary": "Implement vetKey-gated periscope for The Researcher to allow controlled external data access",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-5",
      "summary": "Create backend architecture for 9 total canisters: 8 AI agent canisters representing individual agents in 'The Gang' plus 1 ingestion canister for data processing. Each canister must be independently deployable and have distinct responsibilities within the multi-agent system.",
      "reqIds": [
        "REQ-1"
      ],
      "status": "pending"
    },
    {
      "id": "AR-6",
      "summary": "Implement strict sovereignty model where all canisters are controlled exclusively by the user's Principal ID (Identity #2). No other principals should have control privileges over any canister in the system.",
      "reqIds": [
        "REQ-2"
      ],
      "status": "pending"
    },
    {
      "id": "AR-7",
      "summary": "Implement vetKey-gated periscope mechanism in The Researcher agent canister that serves as the sole controlled gateway for external data access. This must be the only pathway through which data can leave the Internet Computer chain.",
      "reqIds": [
        "REQ-3"
      ],
      "status": "pending"
    },
    {
      "id": "AR-9",
      "summary": "Implement the ingestion canister with methods to receive, validate, and route data to appropriate AI agent canisters. This canister serves as the entry point for all data flowing into The Gang system.",
      "reqIds": [
        "REQ-5"
      ],
      "status": "pending"
    },
    {
      "id": "AR-10",
      "summary": "Build The_Orchestrator backend canister with StableBTreeMap-based file storage (The Bucket) supporting 1.8MB chunk uploads with 390GB cap",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-11",
      "summary": "Define 8 external actor interfaces (Robby, Skippy, The_Architect, Deep_Thought, GLaDOS, VINCENT, Janet, The_Librarian) with ask_agent function signature for inter-canister communication",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-12",
      "summary": "Implement admin configuration function to register Principal IDs for the 8 external LLM agent canisters in The_Orchestrator's state",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-13",
      "summary": "Implement StableBTreeMap in The_Orchestrator backend canister to store file data in stable memory, bypassing the Wasm heap entirely",
      "reqIds": [
        "REQ-7"
      ],
      "status": "pending"
    },
    {
      "id": "AR-14",
      "summary": "Create public upload_chunk function in The_Orchestrator that accepts file chunks strictly up to 1.8MB in size and appends them to file records in the StableBTreeMap",
      "reqIds": [
        "REQ-8"
      ],
      "status": "pending"
    },
    {
      "id": "AR-15",
      "summary": "Implement state variable in The_Orchestrator to track total storage used across all files, and enforce a hard cap of 390GB by trapping or returning an error in upload_chunk when this limit is reached",
      "reqIds": [
        "REQ-9"
      ],
      "status": "pending"
    },
    {
      "id": "AR-16",
      "summary": "Define 8 external actor type interfaces in The_Orchestrator backend for Robby, Skippy, The_Architect, Deep_Thought, GLaDOS, VINCENT, Janet, and The_Librarian, each containing the exact function signature: ask_agent : shared (Text) -> async Text",
      "reqIds": [
        "REQ-10"
      ],
      "status": "pending"
    },
    {
      "id": "AR-17",
      "summary": "Create admin configuration function in The_Orchestrator that allows saving Principal IDs for the 8 external LLM agent canisters (Robby, Skippy, The_Architect, Deep_Thought, GLaDOS, VINCENT, Janet, The_Librarian) into the canister's state",
      "reqIds": [
        "REQ-11"
      ],
      "status": "pending"
    },
    {
      "id": "AR-18",
      "summary": "Create Current_Debate_State record in The_Orchestrator with is_debating, current_speaker, latest_chunk, and full_transcript fields",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-19",
      "summary": "Implement get_debate_status query function in The_Orchestrator that returns Current_Debate_State for frontend polling",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-20",
      "summary": "Implement start_boardroom_debate update function in The_Orchestrator that chains inter-canister calls (Skippy -> GLaDOS -> Robby) and updates state after each agent responds",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-21",
      "summary": "Implement abort_debate update function in The_Orchestrator that sets is_debating to false and accepts user interruption text to append to full_transcript",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-22",
      "summary": "Add kill switch logic to start_boardroom_debate that checks is_debating flag before each inter-canister call and returns early if false",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-23",
      "summary": "Create a stable state variable named Current_Debate_State in The_Orchestrator backend containing the fields: is_debating (Bool), current_speaker (Text), latest_chunk (Text), and full_transcript (Text). Initialize all fields appropriately.",
      "reqIds": [
        "REQ-12"
      ],
      "status": "pending"
    },
    {
      "id": "AR-24",
      "summary": "Implement a public query function named get_debate_status in The_Orchestrator that returns the Current_Debate_State record. This function must be fast and queryable to support 500ms polling from the frontend.",
      "reqIds": [
        "REQ-13"
      ],
      "status": "pending"
    },
    {
      "id": "AR-25",
      "summary": "Implement a public update function named start_boardroom_debate in The_Orchestrator that executes a sequential inter-canister call chain: Skippy -> GLaDOS -> Robby using the ask_agent interface. Before calling each agent, update current_speaker to that agent's name. Immediately after each agent returns, update latest_chunk with the response and append it to full_transcript. Set is_debating to true at the start and false at the end.",
      "reqIds": [
        "REQ-14"
      ],
      "status": "pending"
    },
    {
      "id": "AR-26",
      "summary": "Add kill switch logic to start_boardroom_debate that checks if is_debating is false before making each inter-canister call. If is_debating becomes false during execution, the function must immediately return without making further calls.",
      "reqIds": [
        "REQ-15"
      ],
      "status": "pending"
    },
    {
      "id": "AR-27",
      "summary": "Implement a public update function named abort_debate in The_Orchestrator that accepts a Text argument (the user's interruption message). The function must immediately set is_debating to false and append the interruption text to full_transcript. This enables the frontend to stop the current debate and restart with new context.",
      "reqIds": [
        "REQ-16"
      ],
      "status": "pending"
    },
    {
      "id": "AR-28",
      "summary": "Create DebateState custom type with is_debating, current_speaker, and transcript fields in The_Orchestrator",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-29",
      "summary": "Create global mutable current_state variable of type DebateState initialized with is_debating=false, current_speaker=\"None\", transcript=\"\"",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-30",
      "summary": "Implement public query function get_status that returns current_state",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-31",
      "summary": "Implement public update function update_status(speaker, chunk, active) that overwrites current_speaker, appends chunk to transcript, and updates is_debating",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-32",
      "summary": "Create a custom type called DebateState in The_Orchestrator backend containing three fields: is_debating (Bool), current_speaker (Text), and transcript (Text)",
      "reqIds": [
        "REQ-17"
      ],
      "status": "pending"
    },
    {
      "id": "AR-33",
      "summary": "Create a global mutable state variable called current_state of type DebateState in The_Orchestrator, initialized with is_debating = false, current_speaker = \"None\", and transcript = \"\"",
      "reqIds": [
        "REQ-18"
      ],
      "status": "pending"
    },
    {
      "id": "AR-34",
      "summary": "Create a public query function called get_status in The_Orchestrator that returns the current_state variable",
      "reqIds": [
        "REQ-19"
      ],
      "status": "pending"
    },
    {
      "id": "AR-35",
      "summary": "Create a public update function called update_status in The_Orchestrator that accepts three parameters (speaker: Text, chunk: Text, active: Bool) and updates current_state by overwriting current_speaker with speaker, appending chunk to transcript, and setting is_debating to active",
      "reqIds": [
        "REQ-20"
      ],
      "status": "pending"
    },
    {
      "id": "AR-36",
      "summary": "Create a public update function called start_boardroom_debate in The_Orchestrator backend that accepts a single parameter user_prompt of type Text. Immediately set current_state.is_debating = true at the start of this function.",
      "reqIds": [
        "REQ-21"
      ],
      "status": "pending"
    },
    {
      "id": "AR-37",
      "summary": "In start_boardroom_debate, implement Step 1 (Skippy): Set current_state.current_speaker = \"Skippy\". Call the external Skippy actor using await Skippy.ask_agent(user_prompt). When the await returns, append Skippy's response to current_state.transcript.",
      "reqIds": [
        "REQ-22"
      ],
      "status": "pending"
    },
    {
      "id": "AR-38",
      "summary": "In start_boardroom_debate, implement Step 2 (GLaDOS): Before calling GLaDOS, check if current_state.is_debating is still true. If false, return immediately. If true, set current_state.current_speaker = \"GLaDOS\". Call await GLaDOS.ask_agent(skippy_response) and append GLaDOS's response to current_state.transcript.",
      "reqIds": [
        "REQ-23"
      ],
      "status": "pending"
    },
    {
      "id": "AR-39",
      "summary": "In start_boardroom_debate, implement Step 3 (Robby): Check if current_state.is_debating is still true. If false, return immediately. If true, set current_state.current_speaker = \"Robby\". Call await Robby.ask_agent(glados_response) and append Robby's response to current_state.transcript.",
      "reqIds": [
        "REQ-24"
      ],
      "status": "pending"
    },
    {
      "id": "AR-40",
      "summary": "At the end of start_boardroom_debate (after all agent calls complete or the function returns early), set current_state.is_debating = false and current_state.current_speaker = \"None\".",
      "reqIds": [
        "REQ-25"
      ],
      "status": "pending"
    },
    {
      "id": "AR-41",
      "summary": "Create a public update function called abort_debate in The_Orchestrator backend that accepts a single parameter user_interruption of type Text. This function must immediately set current_state.is_debating = false to trigger the kill switch in start_boardroom_debate.",
      "reqIds": [
        "REQ-26"
      ],
      "status": "pending"
    },
    {
      "id": "AR-42",
      "summary": "In abort_debate, append the user_interruption text to current_state.transcript so the interruption is recorded in the debate history.",
      "reqIds": [
        "REQ-27"
      ],
      "status": "pending"
    },
    {
      "id": "AR-43",
      "summary": "Create custom React hook that polls The_Orchestrator get_status query function every 500ms",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-44",
      "summary": "Build React UI component that displays current_speaker status and streams transcript text in real-time based on polling data",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-45",
      "summary": "Implement 'Push to Talk' button using browser's native SpeechRecognition API to capture user speech and send to backend start_boardroom_debate function",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-46",
      "summary": "Implement native SpeechSynthesis API with useEffect that automatically speaks Robby's response using British Male voice when current_speaker changes to Robby",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-47",
      "summary": "Create prominent 'Interrupt/Stop' button that calls window.speechSynthesis.cancel() and backend abort_debate function to stop debate mid-execution",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-48",
      "summary": "Implement transcript rendering rule that converts product links to HTML anchor tags and strips/blocks all HTML <table> tags from rendering",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-49",
      "summary": "Create commented-out placeholder hook called useWakeWordStub with TODO comment for future @picovoice/porcupine-react integration",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-50",
      "summary": "Integrate @dfinity/auth-client in React frontend and add 'Login with Internet Identity' button to dashboard",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-52",
      "summary": "Import ExperimentalCycles in The_Orchestrator backend and create public update function top_up_swarm(target_canister: Principal, amount: Nat) that attaches cycles using ExperimentalCycles.add(amount) and sends to target_canister",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-53",
      "summary": "Add assert to top_up_swarm function to ensure only authenticated admin (user's Principal) can trigger cycle top-up",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-54",
      "summary": "Add emergency override intercept in start_boardroom_debate: check if user_prompt contains 'HEM_Override_Key', bypass normal routing, set current_speaker='Skippy_Emergency', append 'NCD-16 Override Recognized. Drop the snark. What is the emergency?' to transcript, and set is_debating=false",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-57",
      "summary": "Import ExperimentalCycles module in the Motoko backend main actor file",
      "reqIds": [
        "REQ-38"
      ],
      "status": "pending"
    },
    {
      "id": "AR-58",
      "summary": "Create a public update function called top_up_swarm in the backend that accepts target_canister (Principal) and amount (Nat) parameters, uses ExperimentalCycles.add(amount) to attach cycles from The_Orchestrator's balance, and sends those cycles to the target_canister",
      "reqIds": [
        "REQ-39"
      ],
      "status": "pending"
    },
    {
      "id": "AR-59",
      "summary": "Add an assertion in the top_up_swarm function to ensure only an authenticated admin Principal can trigger the cycle top-up operation",
      "reqIds": [
        "REQ-40"
      ],
      "status": "pending"
    },
    {
      "id": "AR-60",
      "summary": "Add an emergency override intercept at the beginning of the start_boardroom_debate update function that checks if user_prompt contains the exact string 'HEM_Override_Key', and if found, bypasses the normal Skippy -> GLaDOS -> Robby inter-canister routing entirely",
      "reqIds": [
        "REQ-41"
      ],
      "status": "pending"
    },
    {
      "id": "AR-61",
      "summary": "When the emergency override is triggered in start_boardroom_debate, immediately set current_speaker to 'Skippy_Emergency', append the text 'NCD-16 Override Recognized. Drop the snark. What is the emergency?' to the transcript, and set is_debating to false",
      "reqIds": [
        "REQ-42"
      ],
      "status": "pending"
    },
    {
      "id": "AR-62",
      "summary": "Add emergency_mode boolean field to DebateState type in The_Orchestrator backend and initialize it as false",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-63",
      "summary": "Implement 'Steel Rain' trigger in start_boardroom_debate that sets current_state.emergency_mode = true when user_prompt contains 'Steel Rain'",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-64",
      "summary": "Implement persistent emergency routing in start_boardroom_debate: when emergency_mode is true, only call await Skippy.ask_agent(user_prompt), append response to transcript, and return early without calling GLaDOS or Robby",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-65",
      "summary": "Implement 'Stand Down' command in start_boardroom_debate that sets emergency_mode = false, appends 'Emergency Override lifted. Returning to Boardroom protocol.' to transcript, sets is_debating = false, and returns early",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-66",
      "summary": "Add a new boolean field called emergency_mode to the DebateState type in backend/main.mo and initialize it as false in the current_state variable",
      "reqIds": [
        "REQ-43"
      ],
      "status": "pending"
    },
    {
      "id": "AR-67",
      "summary": "In the start_boardroom_debate function, detect if user_prompt contains the text 'Steel Rain' and if found, set current_state.emergency_mode = true",
      "reqIds": [
        "REQ-44"
      ],
      "status": "pending"
    },
    {
      "id": "AR-68",
      "summary": "Implement persistent emergency routing in start_boardroom_debate: immediately after initial setup, check if current_state.emergency_mode is true. If true, only call await Skippy.ask_agent(user_prompt), append Skippy's response to the transcript, and return early without calling GLaDOS or Robby",
      "reqIds": [
        "REQ-45"
      ],
      "status": "pending"
    },
    {
      "id": "AR-69",
      "summary": "In start_boardroom_debate, check if user_prompt contains the exact phrase 'Stand Down'. If found, set current_state.emergency_mode = false, append 'Emergency Override lifted. Returning to Boardroom protocol.' to the transcript, set is_debating = false, and return early",
      "reqIds": [
        "REQ-46"
      ],
      "status": "pending"
    },
    {
      "id": "AR-70",
      "summary": "Define Sensory_Cortex external Actor interface with ask_agent signature in The_Orchestrator backend",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-71",
      "summary": "Add File_Registry (HashMap or array) in The_Orchestrator to track uploaded files with filename, size, and assigned_agent fields",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-72",
      "summary": "Create public update function route_document(filename, file_preview) in The_Orchestrator that calls Sensory_Cortex.ask_agent to determine target agent and saves result to File_Registry",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-73",
      "summary": "Update React 'Sensory Cortex' tab to extract first 5,000 characters from text files (.txt, .csv, .json) using FileReader API as previewString before chunking",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-74",
      "summary": "Call backend route_document(filename, previewString) immediately after 1.8MB chunk upload completes 100% in React frontend",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-75",
      "summary": "Define a new external Actor interface named Sensory_Cortex in The_Orchestrator backend with the function signature: ask_agent : shared (Text) -> async Text",
      "reqIds": [
        "REQ-47"
      ],
      "status": "pending"
    },
    {
      "id": "AR-76",
      "summary": "Add a mutable File_Registry to The_Orchestrator backend to track uploaded files. Each record must store filename (Text), size (Nat), and assigned_agent (Text). Use HashMap or array data structure.",
      "reqIds": [
        "REQ-48"
      ],
      "status": "pending"
    },
    {
      "id": "AR-77",
      "summary": "Create a public update function called route_document in The_Orchestrator that accepts filename (Text) and file_preview (Text) parameters. The function must call await Sensory_Cortex.ask_agent with the prompt: 'Analyze this text and reply with ONLY the target agent name (Skippy, The_Architect, or Staging): ' concatenated with file_preview.",
      "reqIds": [
        "REQ-49"
      ],
      "status": "pending"
    },
    {
      "id": "AR-78",
      "summary": "In the route_document function, save the agent name returned by Sensory_Cortex.ask_agent into the File_Registry for the specified filename. Store the filename, file size, and the returned agent name as the assigned_agent field.",
      "reqIds": [
        "REQ-50"
      ],
      "status": "pending"
    },
    {
      "id": "AR-79",
      "summary": "In the route_document function, append a system message to current_state.transcript with the format: 'SYSTEM: File [' concatenated with filename concatenated with '] processed and routed to ' concatenated with the agent name returned by Sensory_Cortex.",
      "reqIds": [
        "REQ-51"
      ],
      "status": "pending"
    },
    {
      "id": "AR-80",
      "summary": "Refactor App.js to include tabbed navigation with 'Boardroom' and 'Sensory Cortex' buttons using simple state toggle",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-81",
      "summary": "Create Sensory Cortex UI with large, high-contrast drag-and-drop area for file upload",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-82",
      "summary": "Add 'Take Photo' button using <input type='file' accept='image/*' capture='environment'> for mobile camera capture",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-83",
      "summary": "Add 'Select File' button for standard file picker on all devices",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-84",
      "summary": "Style Sensory Cortex interface with dark grays, sharp edges, and emergency vehicle highlights (no purple/blue)",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-85",
      "summary": "Implement sequential chunking engine using for...of loop with exactly 1,800,000 byte chunks",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-86",
      "summary": "Use await on each upload_chunk call to prevent Wasm heap overflow - do not send next chunk until previous one is confirmed",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-87",
      "summary": "Add real-time progress bar showing percentage of file successfully written to Stable Memory",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-88",
      "summary": "After file reaches 100% upload, read first 5,000 characters and call backend route_document(filename, first5KText)",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-89",
      "summary": "Display visual notification: 'Document [X] routed to [Agent Name] via Sensory Cortex' after routing completes",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-90",
      "summary": "Refactor frontend/src/App.tsx to include a navigation bar at the top with two tab buttons labeled 'Boardroom' and 'Sensory Cortex'. Use React state to toggle between displaying the Boardroom Debate interface (current voice UI) and the new Sensory Cortex interface.",
      "reqIds": [
        "REQ-54"
      ],
      "status": "pending"
    },
    {
      "id": "AR-91",
      "summary": "Update internal Agent data structure in The_Orchestrator backend to include is_enabled (Bool) field, defaulting to true",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-92",
      "summary": "Create public update function toggle_agent_status(agent_name: Text, status: Bool) in The_Orchestrator that requires Admin authentication and updates agent is_enabled field",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-93",
      "summary": "Add if (agent.is_enabled) check in start_boardroom_debate before each agent's ask_agent call; if disabled, bypass agent and append '[Agent Name] is currently offline. Bypassing routing segment.' to transcript",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-94",
      "summary": "Build C2 Dashboard UI in 'Swarm Health' tab displaying data table of all 9 AI agents with Toggle/Switch component per agent that calls toggle_agent_status backend function",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-95",
      "summary": "Implement visual indicators in Swarm Health UI: green indicator for enabled agents, red indicator for disabled agents",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-96",
      "summary": "Update the internal Agent data structure in The_Orchestrator backend (backend/main.mo) to include a new boolean field named is_enabled with a default value of true for each agent",
      "reqIds": [
        "REQ-73"
      ],
      "status": "pending"
    },
    {
      "id": "AR-97",
      "summary": "Create a public update function named toggle_agent_status in The_Orchestrator backend that accepts agent_name (Text) and status (Bool) parameters, verifies the caller is the Admin Principal using an assertion, and updates the specified agent's is_enabled field to the provided status value",
      "reqIds": [
        "REQ-74"
      ],
      "status": "pending"
    },
    {
      "id": "AR-98",
      "summary": "Add routing guardrail logic in the start_boardroom_debate function in The_Orchestrator backend: before calling each agent's ask_agent function (Skippy, GLaDOS, Robby), check if the agent's is_enabled field is true. If is_enabled is false, skip the inter-canister call to that agent and append a system message to current_state.transcript in the format: '[Agent Name] is currently offline. Bypassing routing segment.'",
      "reqIds": [
        "REQ-75"
      ],
      "status": "pending"
    },
    {
      "id": "AR-99",
      "summary": "In The_Orchestrator backend, ensure Agent record is initialized with is_enabled = true by default",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-100",
      "summary": "Create public query function get_agent_registry() : async [Agent] in The_Orchestrator backend that returns the current list of all agents and their statuses",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-101",
      "summary": "In Swarm Health tab component, import backend actor and create React state: const [agents, setAgents] = useState([])",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-102",
      "summary": "Use useEffect hook in Swarm Health tab to call await backend.get_agent_registry() on component mount and update the agents state",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-103",
      "summary": "Make the Swarm Health table render dynamically by mapping over the agents state variable, not using hardcoded HTML",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-104",
      "summary": "Update the Toggle component in the mapped Swarm Health table to reflect the true agent.is_enabled boolean",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-105",
      "summary": "Add onChange or onClick handler to the Toggle component in Swarm Health that executes await backend.toggle_agent_status(agent.name, !agent.is_enabled) when clicked",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-106",
      "summary": "After toggle_agent_status resolves in Swarm Health, immediately call backend.get_agent_registry() again to re-fetch fresh data and update UI state",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-107",
      "summary": "In backend/main.mo, ensure the Agent record type includes an is_enabled field of type Bool that defaults to true when agents are initialized in the agent registry",
      "reqIds": [
        "REQ-94"
      ],
      "status": "pending"
    },
    {
      "id": "AR-108",
      "summary": "Create a public query function named get_agent_registry in backend/main.mo with signature get_agent_registry() : async [Agent] that returns the complete current list of all registered agents and their status fields including is_enabled",
      "reqIds": [
        "REQ-95"
      ],
      "status": "pending"
    },
    {
      "id": "AR-109",
      "summary": "Pre-populate the backend Agent Registry in The_Orchestrator with all 9 core agents (Skippy, GLaDOS, Robby, The_Architect, Deep_Thought, VINCENT, Janet, The_Librarian, Sensory_Cortex) upon deployment, each with is_enabled = true by default",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-110",
      "summary": "In backend/main.mo, modify the initialization of the Agent Registry data structure (whether HashMap, Trie, or Array) to be explicitly pre-populated with all 9 core agents upon canister deployment. The agents must be: Skippy, GLaDOS, Robby, The_Architect, Deep_Thought, VINCENT, Janet, The_Librarian, and Sensory_Cortex.",
      "reqIds": [
        "REQ-102"
      ],
      "status": "pending"
    },
    {
      "id": "AR-111",
      "summary": "Set default field values for every pre-populated agent in the registry: is_enabled must be true by default. If the Agent record includes id or cycles tracking fields, set dummy initial values (e.g., id = \"\", last_cycles = 0).",
      "reqIds": [
        "REQ-103"
      ],
      "status": "pending"
    },
    {
      "id": "AR-112",
      "summary": "Verify that the get_agent_registry() query function in backend/main.mo correctly returns the full list of 9 pre-populated agents when called. The function must return this data immediately upon component mount in the frontend, ensuring the Swarm Health table populates with all agents.",
      "reqIds": [
        "REQ-104"
      ],
      "status": "pending"
    },
    {
      "id": "AR-113",
      "summary": "In backend/main.mo, locate the start_boardroom_debate update function. Before executing Skippy's segment, look up 'Skippy' in the Agent Registry state using the exact key string 'Skippy'. Only execute Skippy's mock/stub response if the registry lookup returns an agent record AND agent.is_enabled == true.",
      "reqIds": [
        "REQ-105"
      ],
      "status": "pending"
    },
    {
      "id": "AR-114",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, before executing GLaDOS's segment, look up 'GLaDOS' in the Agent Registry state using the exact key string 'GLaDOS'. Only execute GLaDOS's mock/stub response if the registry lookup returns an agent record AND agent.is_enabled == true.",
      "reqIds": [
        "REQ-106"
      ],
      "status": "pending"
    },
    {
      "id": "AR-115",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, before executing Robby's segment, look up 'Robby' in the Agent Registry state using the exact key string 'Robby'. Only execute Robby's mock/stub response if the registry lookup returns an agent record AND agent.is_enabled == true.",
      "reqIds": [
        "REQ-107"
      ],
      "status": "pending"
    },
    {
      "id": "AR-116",
      "summary": "Verify that the Agent Registry lookup keys used in start_boardroom_debate exactly match the keys used during registry initialization. The keys must be case-sensitive and match exactly: 'Skippy', 'GLaDOS', 'Robby'. Ensure no typos or case mismatches exist between lookup and initialization.",
      "reqIds": [
        "REQ-108"
      ],
      "status": "pending"
    },
    {
      "id": "AR-117",
      "summary": "In backend/main.mo, ensure the start_boardroom_debate function only appends the 'bypassing' offline message when agent.is_enabled is explicitly false. When is_enabled is true, append the mock/stub response text to the transcript as normal.",
      "reqIds": [
        "REQ-109"
      ],
      "status": "pending"
    },
    {
      "id": "AR-121",
      "summary": "In backend/main.mo, locate the start_boardroom_debate function. Before appending Skippy's mock response to the transcript, look up the agent named 'Skippy' in the Agent Registry state. Only append Skippy's response if the registry returns an agent record with is_enabled == true. If is_enabled == false, append the system message 'Skippy is currently offline. Bypassing...' to the transcript instead",
      "reqIds": [
        "REQ-113"
      ],
      "status": "pending"
    },
    {
      "id": "AR-122",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, before appending GLaDOS's mock response to the transcript, look up the agent named 'GLaDOS' in the Agent Registry state. Only append GLaDOS's response if the registry returns an agent record with is_enabled == true. If is_enabled == false, append the system message 'GLaDOS is currently offline. Bypassing...' to the transcript instead",
      "reqIds": [
        "REQ-114"
      ],
      "status": "pending"
    },
    {
      "id": "AR-123",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, before appending Robby's mock response to the transcript, look up the agent named 'Robby' in the Agent Registry state. Only append Robby's response if the registry returns an agent record with is_enabled == true. If is_enabled == false, append the system message 'Robby is currently offline. Bypassing...' to the transcript instead",
      "reqIds": [
        "REQ-115"
      ],
      "status": "pending"
    },
    {
      "id": "AR-124",
      "summary": "Add guard clause at the beginning of Boardroom component render that returns <div>Connecting to The Gang...</div> if !backend",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-125",
      "summary": "Add finally block to async function calling backend.start_boardroom_debate that resets loading state variables (setIsDebating(false), setIsRecording(false)) to prevent buttons getting stuck in disabled state on error",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-126",
      "summary": "Fix Boardroom component to correctly import and use the backend actor from the same global AuthContext/useAuth hook that SwarmHealth and SensoryCortex use. Ensure the backend variable is populated from live global state and is not shadowed by local declarations or undefined assignments.",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-127",
      "summary": "Remove any dead local variables in the Boardroom component that initialize backend to null or undefined. The backend must be pulled from the global Auth state/context using the same pattern as other components.",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-128",
      "summary": "Ensure the Boardroom component re-renders automatically when the global Auth state initializes the backend actor. The component should drop the 'Connecting to The Gang...' loading screen the moment the backend actor resolves from the global context.",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-129",
      "summary": "Add setTranscript([]) to clear transcript state at the start of each new Push-to-Talk recording in Boardroom component",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-130",
      "summary": "Add fallback in start_boardroom_debate backend function: if registry lookup fails for an agent, default to { is_enabled: true } to prevent false offline status",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-131",
      "summary": "In frontend/src/components/DebateDisplay.tsx, locate and permanently delete the string 'Authentication required to view Robby's responses and enable Text-to-Speech.' from the component render output. This text should not exist anywhere in the component code.",
      "reqIds": [
        "REQ-126"
      ],
      "status": "pending"
    },
    {
      "id": "AR-133",
      "summary": "In backend/main.mo, locate the start_boardroom_debate function. For each agent lookup in the registry (Skippy, GLaDOS, Robby), add a fallback operator to prevent false offline status. If the registry.get(agentName) returns null, default to { is_enabled = true }. Use the Motoko null coalescing pattern: let agentStatus = registry.get(agentName) ?? { is_enabled = true };",
      "reqIds": [
        "REQ-128"
      ],
      "status": "pending"
    },
    {
      "id": "AR-134",
      "summary": "Restore try/catch/finally safety net in handlePushToTalk to prevent White Screen of Death when backend call fails",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-135",
      "summary": "Add setTranscript([]) at the very start of handlePushToTalk function to clear transcript stream before each new recording",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-134",
      "summary": "Restore try/catch/finally safety net in handlePushToTalk to prevent White Screen of Death when backend call fails",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-135",
      "summary": "Add setTranscript([]) at the very start of handlePushToTalk function to clear transcript stream before each new recording",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-145",
      "summary": "In backend/main.mo, remove all cross-canister calls (await agent.askAgent) from start_boardroom_debate and replace with hardcoded mock responses to fix IC0536 error",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-146",
      "summary": "In backend/main.mo, locate the start_boardroom_debate update function and completely remove all cross-canister call logic including any await agent.askAgent(...) calls, Actor lookups, and Principal ID references to external agent canisters",
      "reqIds": [
        "REQ-136"
      ],
      "status": "pending"
    },
    {
      "id": "AR-147",
      "summary": "In backend/main.mo, refactor start_boardroom_debate to accept the user's prompt parameter and return a single hardcoded Text string that simulates a multi-agent debate transcript with format: 'User: [prompt]\\n\\nSkippy: This is a stubbed response for Skippy.\\n\\nGLaDOS: This is a stubbed response for GLaDOS.\\n\\nRobby: This is a stubbed response for Robby.'",
      "reqIds": [
        "REQ-137"
      ],
      "status": "pending"
    },
    {
      "id": "AR-148",
      "summary": "In backend/main.mo, ensure start_boardroom_debate updates current_state.transcript with the hardcoded mock transcript string before returning, and sets current_state.is_debating to false at the end of execution",
      "reqIds": [
        "REQ-138"
      ],
      "status": "pending"
    },
    {
      "id": "AR-149",
      "summary": "In backend/main.mo, remove all Agent Registry lookups for is_enabled checks in start_boardroom_debate since we are stubbing the debate with hardcoded responses and not routing to real agents",
      "reqIds": [
        "REQ-139"
      ],
      "status": "pending"
    },
    {
      "id": "AR-150",
      "summary": "Fix React Error 185 infinite render loop in Boardroom component by ensuring all state setters are only called inside event handlers or useEffect with strict dependency arrays",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-151",
      "summary": "Replace entire start_boardroom_debate function in backend/main.mo with hardcoded return string: 'Skippy: This is a stubbed response.\\n\\nGLaDOS: This is a stubbed response.\\n\\nRobby: This is a stubbed response.' with no additional logic",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-152",
      "summary": "In frontend/src/App.tsx, locate the Boardroom component render body and all useEffect hooks. Identify any state setter calls (setTranscript, setIsDebating, setIsRecording, or similar) that are being executed directly in the render body or inside a useEffect without a proper dependency array. Move all state updates to explicit event handlers (onClick, onSubmit, etc.) or wrap them in useEffect with strict dependency arrays like [] or [specificDependency].",
      "reqIds": [
        "REQ-140"
      ],
      "status": "pending"
    },
    {
      "id": "AR-153",
      "summary": "In backend/main.mo, locate the start_boardroom_debate function and replace the ENTIRE function body with exactly this code: public shared(msg) func start_boardroom_debate(prompt: Text) : async Text { return \"Skippy: This is a stubbed response.\\n\\nGLaDOS: This is a stubbed response.\\n\\nRobby: This is a stubbed response.\"; }; Do NOT add any other logic to this function. Remove all agent registry lookups, all is_enabled checks, all cross-canister calls, and all state updates. The function must ONLY return that exact hardcoded string.",
      "reqIds": [
        "REQ-141"
      ],
      "status": "pending"
    },
    {
      "id": "AR-154",
      "summary": "In backend/main.mo, modify start_boardroom_debate to dynamically construct response string by checking Agent Registry is_enabled status for Skippy, GLaDOS, and Robby without any cross-canister calls",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-155",
      "summary": "In backend/main.mo, locate the start_boardroom_debate function. At the beginning of the function, create a mutable text variable using var response = \"\";",
      "reqIds": [
        "REQ-142"
      ],
      "status": "pending"
    },
    {
      "id": "AR-156",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, look up 'Skippy' in the Agent Registry data structure. If the registry lookup succeeds and agent.is_enabled is true, append 'Skippy: This is a stubbed response.\\n\\n' to the response variable. If is_enabled is false or the lookup fails, append 'Skippy is offline. Bypassed.\\n\\n' to the response variable.",
      "reqIds": [
        "REQ-143"
      ],
      "status": "pending"
    },
    {
      "id": "AR-157",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, look up 'GLaDOS' in the Agent Registry data structure. If the registry lookup succeeds and agent.is_enabled is true, append 'GLaDOS: This is a stubbed response.\\n\\n' to the response variable. If is_enabled is false or the lookup fails, append 'GLaDOS is offline. Bypassed.\\n\\n' to the response variable.",
      "reqIds": [
        "REQ-144"
      ],
      "status": "pending"
    },
    {
      "id": "AR-158",
      "summary": "In backend/main.mo, in the start_boardroom_debate function, look up 'Robby' in the Agent Registry data structure. If the registry lookup succeeds and agent.is_enabled is true, append 'Robby: This is a stubbed response.\\n\\n' to the response variable. If is_enabled is false or the lookup fails, append 'Robby is offline. Bypassed.\\n\\n' to the response variable.",
      "reqIds": [
        "REQ-145"
      ],
      "status": "pending"
    },
    {
      "id": "AR-159",
      "summary": "In backend/main.mo, at the end of the start_boardroom_debate function after all agent status checks are complete, return the final constructed response text string to the frontend. The function signature must remain public shared(msg) func start_boardroom_debate(prompt: Text) : async Text.",
      "reqIds": [
        "REQ-146"
      ],
      "status": "pending"
    },
    {
      "id": "AR-160",
      "summary": "Fix SwarmHealth component: Change toggle onChange handlers to use arrow functions (onChange={() => handleToggle(agent.id)}), add try/catch/finally blocks that reset loading state (setUpdatingId(null)) in finally block to prevent stuck buttons",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-161",
      "summary": "Fix Boardroom layout shift: Add static CSS minimum height (min-h-[400px] or style={{ minHeight: '400px' }}) to the container div holding the Transcript Stream to prevent UI collapse when transcript is cleared",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-162",
      "summary": "Fix Boardroom Error 185: Audit Boardroom component for state setters called directly in render body and move them into explicit event handlers or useEffect hooks with strict dependency arrays",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-165",
      "summary": "In frontend/src/App.tsx or the Boardroom component section, locate the container div that holds the Transcript Stream display. Add a static CSS minimum height using either Tailwind class min-h-[400px] or inline style={{ minHeight: '400px' }} to prevent the UI from collapsing when setTranscript([]) empties the transcript content.",
      "reqIds": [
        "REQ-149"
      ],
      "status": "pending"
    },
    {
      "id": "AR-166",
      "summary": "In frontend/src/App.tsx, audit the Boardroom component render body and all useEffect hooks to identify any state setter calls (setTranscript, setIsDebating, setIsRecording, or similar) that are being executed directly in the main render body outside of event handlers. Move all such state updates to explicit event handlers (onClick, onSubmit, etc.) or wrap them in useEffect hooks with strict dependency arrays like [] or [specificDependency].",
      "reqIds": [
        "REQ-150"
      ],
      "status": "pending"
    },
    {
      "id": "AR-167",
      "summary": "Fix AuthProvider actor initialization by importing backend declarations and creating actor with user's identity after authentication: const actor = createActor(canisterId, { agentOptions: { identity: authClient.getIdentity() } }); setBackend(actor);",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-168",
      "summary": "Clean up Boardroom and SwarmHealth UI to use strict early returns that render ONLY ONE message at a time in exact order: isLoading -> 'Checking session...', !isAuthenticated -> 'Please authenticate to continue.', !backend -> 'Connecting to The Orchestrator...', then main UI",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-169",
      "summary": "In the file managing Auth Context (likely frontend/src/hooks/useInternetIdentity.ts or a custom AuthProvider component), import the backend declarations using the exact import statement: import { createActor, canisterId } from '../../declarations/backend'; or the equivalent path to your local backend declarations",
      "reqIds": [
        "REQ-155"
      ],
      "status": "pending"
    },
    {
      "id": "AR-170",
      "summary": "Inside the useEffect hook that handles successful Internet Identity authentication in the Auth Context, instantiate the backend actor using the authenticated user's identity with the exact code: const actor = createActor(canisterId, { agentOptions: { identity: authClient.getIdentity() } }); followed immediately by setBackend(actor); to populate the backend state variable",
      "reqIds": [
        "REQ-156"
      ],
      "status": "pending"
    },
    {
      "id": "AR-171",
      "summary": "Wrap createActor call in AuthProvider with try/catch block to log ACTOR CREATION FAILED errors and prevent silent crashes",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-172",
      "summary": "Remove all guard clauses (if (!backend), if (isLoading)) from main App.tsx layout component - layout should only render Header/Navbar and content area without loading spinners or error messages",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-173",
      "summary": "Enforce strict early return pattern in Boardroom component at the very top: if (isLoading) return checking session message, if (!isAuthenticated) return authenticate message, if (!backend) return actor missing message with console error reference",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-174",
      "summary": "Enforce strict early return pattern in SwarmHealth component at the very top: if (isLoading) return checking session message, if (!isAuthenticated) return authenticate message, if (!backend) return actor missing message with console error reference",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-175",
      "summary": "Enforce strict early return pattern in SensoryCortex component at the very top: if (isLoading) return checking session message, if (!isAuthenticated) return authenticate message, if (!backend) return actor missing message with console error reference",
      "reqIds": [],
      "status": "pending"
    },
    {
      "id": "AR-176",
      "summary": "In the file managing Auth Context (frontend/src/hooks/useInternetIdentity.ts or the AuthProvider component), wrap the createActor logic in a strict try/catch block. In the try block, execute: const actor = createActor(canisterId, { agentOptions: { identity: authClient.getIdentity() } }); setBackend(actor);. In the catch block, log the error using console.error('ACTOR CREATION FAILED:', error); to prevent silent failures and provide visibility into initialization errors.",
      "reqIds": [
        "REQ-159"
      ],
      "status": "pending"
    },
    {
      "id": "AR-177",
      "summary": "In the Auth Context file (frontend/src/hooks/useInternetIdentity.ts or AuthProvider), verify that the import statement for createActor and canisterId points to the correct local declarations folder. The import must use the exact path to the generated backend declarations, typically: import { createActor, canisterId } from '../../declarations/backend'; or the equivalent correct path for this project structure.",
      "reqIds": [
        "REQ-160"
      ],
      "status": "pending"
    }
  ],
  "gameProjectType": "none",
  "projectName": "The Gang",
  "clarification_mode": "instant",
  "clarification_rounds": 0
}